pragma solidity 0.6.8;

import "@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract Invert is ERC721Burnable {
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdTracker;

    // Mapping from creator address to their (enumerable) set of created tokens
    mapping (address => EnumerableSet.UintSet) private _creatorTokens;

    constructor() public ERC721("Invert", "INVERT") {}

    function tokenOfCreatorByIndex(address creator, uint256 index) external view  returns (uint256) {
        return _creatorTokens[creator].at(index);
    }

    /**
    * @dev Creates a new token for `creator`. Its token ID will be automatically
    * assigned (and available on the emitted {IERC721-Transfer} event), and the token
    * URI autogenerated based on the base URI passed at construction.
    *
    * See {ERC721-_safeMint}.
    */
    function mint(address creator, string memory tokenURI) public virtual {
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        uint256 tokenId = _tokenIdTracker.current();

        _safeMint(creator, tokenId);
        _tokenIdTracker.increment();

        _setTokenURI(tokenId, tokenURI);
        _creatorTokens[creator].add(tokenId);
    }
}